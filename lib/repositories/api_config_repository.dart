import 'package:logging/logging.dart';
import '../data/database/app_database.dart';
import '../data/database/daos/api_config_dao.dart';

// The ApiConfigRepository now works directly with the `ApiConfig` data class
// generated by Drift from the `api_configs` table.
// It provides a clean interface to the UI/Provider layer.

class ApiConfigRepository {
  final _log = Logger('ApiConfigRepository');
  final ApiConfigDao _dao;

  ApiConfigRepository(this._dao);

  // --- Unified API Config Methods ---

  Future<List<ApiConfig>> getAllConfigs() => _dao.getAllApiConfigs();

  Stream<List<ApiConfig>> watchAllConfigs() => _dao.watchAllApiConfigs();

  Future<ApiConfig?> getConfigById(String id) => _dao.getApiConfigById(id);

  // The `upsert` method handles both inserts and updates.
  // The UI layer will be responsible for creating the `ApiConfigsCompanion`.
  Future<void> saveConfig(ApiConfigsCompanion companion) {
    return _dao.upsertApiConfig(companion);
  }

  Future<void> deleteConfig(String id) => _dao.deleteApiConfig(id);
  
  Future<void> clearAllConfigs() => _dao.clearAllApiConfigs();

  // Data migration logic can be added here.
  // This method would be called once upon app initialization.
  Future<void> migrateOldConfigs() async {
    // This is a placeholder for the complex migration logic.
    // It would involve:
    // 1. Reading from the (now-hidden) old `GeminiApiKeys` and `OpenAIConfigs` tables.
    // 2. Creating new `ApiConfig` entries for each old config.
    // 3. Updating all chats to point to the new `apiConfigId`.
    // 4. After successful migration, the old tables can be dropped in a future schema version.
    _log.info("Placeholder for data migration logic.");
  }
}